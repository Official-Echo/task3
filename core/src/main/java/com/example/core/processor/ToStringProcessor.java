
package com.example.core.processor;

import com.example.core.annotations.GenerateToString;

import javax.annotation.processing.AbstractProcessor;
import javax.annotation.processing.RoundEnvironment;
import javax.annotation.processing.SupportedAnnotationTypes;
import javax.annotation.processing.SupportedSourceVersion;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.Element;
import javax.lang.model.element.ElementKind;
import javax.lang.model.element.TypeElement;
import javax.lang.model.element.VariableElement;
import javax.tools.JavaFileObject;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

@SupportedAnnotationTypes("com.example.core.annotations.GenerateToString")
@SupportedSourceVersion(SourceVersion.RELEASE_21)
public class ToStringProcessor extends AbstractProcessor {

	@Override
	public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
		for (Element element : roundEnv.getElementsAnnotatedWith(GenerateToString.class)) {
			if (element.getKind() == ElementKind.CLASS) {
				TypeElement classElement = (TypeElement) element;
				GenerateToString annotation = classElement.getAnnotation(GenerateToString.class);
				generateToStringHelper(classElement, annotation);
			}
		}
		return true;
	}

	private void generateToStringHelper(TypeElement classElement, GenerateToString annotation) {
		String className = classElement.getSimpleName().toString();
		String packageName = processingEnv.getElementUtils().getPackageOf(classElement).getQualifiedName().toString();
		String helperClassName = className + "ToStringHelper";

		try {
			JavaFileObject builderFile = processingEnv.getFiler().createSourceFile(packageName + "." + helperClassName);

			try (PrintWriter out = new PrintWriter(builderFile.openWriter())) {
				out.println("package " + packageName + ";");
				out.println();
				out.println("// Generated by ToStringProcessor");
				out.println("public class " + helperClassName + " {");
				out.println();

				List<VariableElement> fields = classElement.getEnclosedElements().stream()
						.filter(e -> e.getKind() == ElementKind.FIELD)
						.map(e -> (VariableElement) e)
						.collect(Collectors.toList());

				out.println("    public static String toString(" + className + " obj) {");
				out.println("        StringBuilder sb = new StringBuilder();");

				String prefix = annotation.prefix().isEmpty() ? className : annotation.prefix();
				out.println("        sb.append(\"" + prefix + "{\");");

				for (int i = 0; i < fields.size(); i++) {
					VariableElement field = fields.get(i);
					String fieldName = field.getSimpleName().toString();
					String getterName = "get" + Character.toUpperCase(fieldName.charAt(0)) + fieldName.substring(1);

					if (annotation.includeFieldNames()) {
						out.println("        sb.append(\"" + fieldName + "='\");");
					}
					out.println("        sb.append(obj." + getterName + "());");
					if (annotation.includeFieldNames()) {
						out.println("        sb.append(\"'\");");
					}

					if (i < fields.size() - 1) {
						out.println("        sb.append(\", \");");
					}
				}

				out.println("        sb.append(\"}\");");
				out.println("        return sb.toString();");
				out.println("    }");
				out.println("}");
			}
		} catch (IOException e) {
			processingEnv.getMessager().printMessage(
					javax.tools.Diagnostic.Kind.ERROR,
					"Could not create helper class: " + e.getMessage());
		}
	}
}